package SolutionLeetCode;

import java.util.*;
import java.util.stream.Collectors;

class Solution {
    static boolean isVowel(char c) {
        return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||
                c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U';
    }

    static void swap(char[] chars, int x, int y) {
        char c = chars[x];
        chars[x] = chars[y];
        chars[y] = c;
    }

    public static String reverseVowels(String s) {
        int i = 0;
        int j = s.length() - 1;
        boolean startOrEnd = true;
        char[] chars = s.toCharArray();

        while (i < j) {
            while (startOrEnd && i < j) {
                if (isVowel(chars[i])) {
                    startOrEnd = false;
                } else {
                    i++;
                }
            }
            while (!startOrEnd) {
                if (isVowel(chars[j])) {
                    startOrEnd = true;
                } else {
                    j--;
                }
            }
            swap(chars, i, j);
            i++;
            j--;
        }
        return String.valueOf(chars);
    }


    public static String reverseWords(String s) {
        if(s.contains(" ")) {
            String a = "";
            s = subString(s);
            a = s.substring(0, s.indexOf(" ")) + a;
            s = s.substring(s.indexOf(" ") + 1);
            s = subString(s);
            while (s.contains(" ")) {
                a = s.substring(0, s.indexOf(" ")) + " " + a;
                s = s.substring(s.indexOf(" ") + 1);
                s = subString(s);
            }
            a = s + " " + a;
            a = subString(a);
            return a;
        } else {
            return s;
        }
    }

    static String subString(String s) {
        while (s.indexOf(" ") == 0) {
            s = s.substring(s.indexOf(" ") + 1);
        }
        return s;
    }

    public static int[] productExceptSelf(int[] nums) {
        int mult = 1;
        int[] result = new int[nums.length];
        for(int i = 0; i < nums.length; i++) {
            result[i] = 1 * mult;
            mult *= nums[i];
            for(int j = 0; j < i; j++) {
                result[j] *= nums[i];
            }
        }
        return result;
    }

    /*public void moveZeroes(int[] nums) {
        nums = Arrays.asList(nums).stream()
                .sorted((p1,p2) -> {
                    int a = p1;
                    int b = p2;

                    if (p1 == 0 && p2 == 0) return 0;
                    if (p1 == 0) return 1;
                    if (p2 == 0) return -1;
                    return Integer.compare(p1, p2);
                })
                .collect(Collectors.toList());
    }*/

    public void moveZeroes() {
        ArrayList<Integer> RI = new ArrayList<>();
        Random rnd = new Random();

        for(int i = 0; i < 10; i++) {
            RI.add(rnd.nextInt(100));
        }

        System.out.println(RI.toString());

        int count = (int) RI.stream()
                .filter(a -> a % 2 == 0)
                .count();
        System.out.println(count);

        ArrayList<Integer> lower50 = new ArrayList<>(RI.stream()
                .filter(a -> a <= 50)
                .collect(Collectors.toList()));

        System.out.println(lower50.toString());

        System.out.println(RI.stream()
                .filter(a -> a <= 50)
                .map(a -> a + 100)
                .sorted()
                .collect(Collectors.toList()));

    }

    public boolean validPath(int n, int[][] edges, int source, int destination) {
            if (source == destination) {
                return true;
            }

            int[][] normalFuckingEdge = new int[n][n];
            for(int[] edge : edges) {
                normalFuckingEdge[edge[0]][edge[1]] = 2;
                normalFuckingEdge[edge[1]][edge[0]] = 2;
            }

            Stack<Integer> stack = new Stack<>();
            Vertex[] arrayVertex = new Vertex[n];
            for (int i = 0; i < n; i++) {
                arrayVertex[i] = new Vertex(i);
            }
            boolean isFindTheWay = false;
            arrayVertex[source].setVisited(true);

            stack.push(source);
            while (!stack.empty()) {
                int currentVertex = stack.peek();
                int v = currentVertex;

                for (int i = 0; i < n; i++) {
                    if (normalFuckingEdge[v][i] == 2 && arrayVertex[i].isVisited() == false) {
                        if (arrayVertex[i].getNumber() == destination) {
                            isFindTheWay = true;
                            break;
                        } else {
                            v = i;
                            break;
                        }
                    }
                }

                if (v == currentVertex) {
                    v = -1;
                }

                if (v == -1) {
                    stack.pop();
                } else {
                    arrayVertex[v].setVisited(true);
                    stack.push(v);
                }
            }

            return isFindTheWay;
        }

    class Vertex {
        private int number;
        private boolean isVisited;
        public Vertex(int number) {
            this.number = number;
            isVisited = false;
        }

        public int getNumber() {
            return number;
        }

        public void setNumber(int number) {
            this.number = number;
        }

        public boolean isVisited() {
            return isVisited;
        }

        public void setVisited(boolean visited) {
            isVisited = visited;
        }
    }
}